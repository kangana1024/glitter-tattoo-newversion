import * as fs from 'fs';
import * as path from 'path';

const MANIFEST_PATH = path.join(process.cwd(), 'scraped-data', 'manifest.json');
const LEGACY_INDEX_PATH = path.join(process.cwd(), 'content', 'legacy', 'pages.json');

/**
 * Mapping rules: convert discovered old paths to new curated pages.
 * These take priority over legacy page rendering.
 */
const PATH_RULES: Array<{ match: RegExp; newPath: string }> = [
  { match: /^\/(index|home)\.html?$/i, newPath: '/' },
  { match: /^\/home_(en|eng|ch)\.html?$/i, newPath: '/' },
  { match: /^\/home_(en|eng|ch)\.php$/i, newPath: '/' },
  { match: /^\/2015\/?(index\.html?)?$/i, newPath: '/' },
  { match: /^\/2015\/index_th\.php$/i, newPath: '/' },
  { match: /^\/2015\/index\.php$/i, newPath: '/' },
  { match: /^\/2015\/th\.about_us\.php$/i, newPath: '/about' },
  { match: /^\/about_us_(en|th)\.html?$/i, newPath: '/about' },
  { match: /^\/2015\/about(_en|_ch)?\.html?$/i, newPath: '/about' },
  { match: /^\/about\.html?$/i, newPath: '/about' },
  { match: /^\/2015\/th\.product_(professional|diy2|stencil_pack|stencil\d*|powder\d*|accessories)\.php$/i, newPath: '/services' },
  { match: /^\/2015\/products(_en|_ch)?\.html?$/i, newPath: '/services' },
  { match: /^\/products?\.html?$/i, newPath: '/services' },
  { match: /^\/2015\/th\.(paint_service|event_service|create_premium|create_glitter)\.php$/i, newPath: '/services' },
  { match: /^\/2015\/gallery(_en|_ch)?\.html?$/i, newPath: '/gallery' },
  { match: /^\/gallery\.html?$/i, newPath: '/gallery' },
  { match: /^\/2015\/th\.contact_us\.php$/i, newPath: '/contact' },
  { match: /^\/contact_us_(en|th)\.php$/i, newPath: '/contact' },
  { match: /^\/2015\/contact(_en|_ch)?\.html?$/i, newPath: '/contact' },
  { match: /^\/contact\.html?$/i, newPath: '/contact' },
];

function mapPathToNew(oldPath: string): string | null {
  const cleaned = oldPath.split('?')[0].split('#')[0];
  for (const rule of PATH_RULES) {
    if (rule.match.test(cleaned)) {
      return rule.newPath;
    }
  }
  return null;
}

function generateRedirectMapSource(redirects: Map<string, string>): string {
  const entries = Array.from(redirects.entries())
    .sort(([a], [b]) => a.localeCompare(b));

  const lines = entries.map(([oldPath, newPath]) => `  '${oldPath}': '${newPath}',`);

  return `/**
 * Mapping of old (legacy) URL paths to new URL paths.
 * Used by the catch-all route app/[locale]/[...rest]/page.tsx
 * to redirect visitors from old URLs to the correct new pages.
 *
 * Keys are old paths (without locale prefix).
 * Values are new paths (without locale prefix).
 *
 * Auto-generated by scripts/generate-redirects.ts
 */
export const redirectMap: Record<string, string> = {
${lines.join('\n')}
};
`;
}

async function main(): Promise<void> {
  process.stderr.write('=== Generating Redirect Map ===\n');

  const redirects = new Map<string, string>();

  // 1. Load manifest to get all scraped URLs
  if (fs.existsSync(MANIFEST_PATH)) {
    const manifest = JSON.parse(fs.readFileSync(MANIFEST_PATH, 'utf-8'));
    const pages: Array<{ url: string }> = manifest.pages || [];

    for (const page of pages) {
      try {
        const urlPath = new URL(page.url).pathname;
        const newPath = mapPathToNew(urlPath);
        if (newPath !== null) {
          redirects.set(urlPath, newPath);
        }
      } catch {
        // skip invalid URLs
      }
    }

    process.stderr.write(`  From manifest: ${redirects.size} redirect entries\n`);
  } else {
    process.stderr.write('  Warning: manifest.json not found. Using predefined rules only.\n');
  }

  // 2. Load legacy index to find pages that already have direct content
  // These should NOT be in redirect map (they're rendered directly)
  let legacyPaths = new Set<string>();
  if (fs.existsSync(LEGACY_INDEX_PATH)) {
    const legacyIndex = JSON.parse(fs.readFileSync(LEGACY_INDEX_PATH, 'utf-8'));
    legacyPaths = new Set(legacyIndex.paths || []);
    process.stderr.write(`  Legacy pages (excluded from redirects): ${legacyPaths.size}\n`);
  }

  // 3. Remove redirects for paths that have direct legacy content
  for (const legacyPath of legacyPaths) {
    redirects.delete(legacyPath);
  }

  // 4. Add known legacy paths that should always redirect
  const knownRedirects: Array<[string, string]> = [
    ['/home_en.html', '/'],
    ['/home_ch.html', '/'],
    ['/home.html', '/'],
    ['/2015/index.html', '/'],
  ];

  for (const [oldPath, newPath] of knownRedirects) {
    if (!legacyPaths.has(oldPath) && !redirects.has(oldPath)) {
      redirects.set(oldPath, newPath);
    }
  }

  // 5. Generate the TypeScript source
  const source = generateRedirectMapSource(redirects);
  const outputPath = path.join(process.cwd(), 'lib', 'redirect-map.ts');
  fs.writeFileSync(outputPath, source);

  process.stderr.write(`\n=== Done ===\n`);
  process.stderr.write(`  Total redirects: ${redirects.size}\n`);
  process.stderr.write(`  Output: lib/redirect-map.ts\n`);
}

main().catch((err) => {
  process.stderr.write(`Fatal error: ${(err as Error).message}\n`);
  process.exit(1);
});
